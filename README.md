Цели и задачи работы: изучение алгоритмов работы с абстрактными структурами данных.
Задание к работе: Самостоятельно решить задачи в соответствии с индивидуальным вариантом.
Методика выполнения работы:
1.	Разработать алгоритм решения задачи по индивидуальному заданию.
2.	Написать и отладить программу решения задачи (С, Go или Rust).
3.	Протестировать работу программы на различных исходных данных.
4.	По запросу преподавателя быть готовым модифицировать алгоритм и добавить операцию работы с данными.


Задание №1. Стек.
Вариант 2
Значение логического выражения
Задано логическое выражение. Необходимо вычислить его значение. В выражении могут встречаться знаки: ! (отрицание), & (логическое «и»), | (логическое «или»), ^ (XOR – «исключающее ИЛИ», «ровно одно из двух – истина») и скобки. Самый высокий приоритет у отрицания, меньше – у &, операции | и ^ имеют самый низкий приоритет (одинаковый) и вычисляются слева направо. Все числа в выражении либо 0, либо 1.

Задание №2. АТД множество.
Реализовать основные операции со множеством: добавление элемента, удаление элемента, проверка наличия элемента в множестве.
Запуск задания в консоли:
./<имя вашей программы> --file <путь до файла с данными> --query <запрос к файлу с данными>
Все операции выполняются за O(1)
Таблица операций
Тип контейнера	Добавление	Удаление	Проверка, является ли элемент частью множества
Множество	SETADD	SETDEL	SET_AT

Задание №3. Множество.
Вариант 2
Схожие подмножества
Необходимо реализовать алгоритм, который должен разбить множество натуральных чисел на непересекающиеся подмножества, разница между суммами которых была бы минимальна. Вывести получившиеся подмножества и разницу их сумм.
Пример:
множество S = {5, 8, 1, 14, 7}.
Получим два подмножества {5, 14} и {8, 1, 7}. Разница между их суммами – 3.

Задание №4. Массив.
Вариант 2
Поиск суммы
Необходимо реализовать алгоритм, который находит подмассив, сумма элементов которого равна заданному числу.
Пример:
Массив [4, -7, 1, 5, -4, 0, -3, 2, 4, 1], цель 5.
Подмассивы: [5]
[4, 1]
[5, -4, 0, -3, 2, 4, 1]
[1, 5, -4, 0, -3, 2, 4]

Задание №5. Двоичное дерево.
Вариант 4
Вывод развилок
Для бинарного дерева поиска, построенного на заданных элементах, выведите список всех вершин, имеющих по два ребёнка, в порядке возрастания.
Вводится последовательность целых чисел, оканчивающаяся нулем. Сам ноль в последовательность не входит. Постройте по этой последовательности дерево.
Пример:
Ввод: 7 3 2 1 9 5 4 6 8 0
Вывод: 3 5 7

Задание №6. Хеш-таблица.
Общее задание по вариантам
Реализовать хеш-таблицу.
Вариант 2
Двойное хеширование и Хеширование кукушки
Проведите эмпирический анализ хеширования двумя представленными методами, определите время выполнения M поисков при заданной последовательности N элементов.
Вариант 2
Реструктуризация
Реализуйте функцию реструктуризации хеш-таблицы в случае ее заполнения, а именно – когда таблица заполнена на 90%, создайте новую хеш-таблицу размером в два раза большим и передайте в нее все ключи. При этом для всех ключей выполняется повторное хеширование и повторная вставка в таблицу. Рекомендуется использовать библиотеку работы с большими числами.

Задание №7. LRU/LFU.
Вариант 2
LFU кэш
Разработайте структуру данных, которая работает как кэш LeastFrequentlyUsed. На вход подается запрос, который может быть двух типов:
SET x y: устанавливает значение ключа x со значением y. Если кэш достигает своей емкости, должен быть аннулирован элемент, к которому обращались реже всего.
GET x: возвращает ключ x, если он присутствует, иначе возвращает – 1.
В конструкторе класса должна быть инициализирована емкость кэша.
Пример:
cap обозначает емкость кэша, а Q – количество запросов.
cap = 2, Q = 2
Queries = SET(5,7) SET (4,6) SET (3,5) SET (2,4) SET (1,3) GET(1) GET (2) GET (3) GET (4) GET (5)
Вывод: 3 4 5 -1 -1.
При выполнении SET(2,4), (5,7) становится недействительным.
Аналогично, когда выполняется SET(1,3), (4,6) становится недействительным.


Структура проекта: array.cpp, stack.cpp, hash_table.cpp, set.cpp, lfu.cpp, tree.cpp - cpp файлы структур на C++; array.h, stack.h, hash_table.h, set.h, lfu.h, tree.h - header файлы структур на C++; tasks.cpp и tasks.h - cpp и header файлы с выполнением всех заданий на C++; main.cpp - основной файл проекта на C++;
array.go, stack.go, hash_table.go, set.go, lfu.go, tree.go - файлы структур на Go; tasks.go - файл с выполнением всех заданий на Go; main.go - основной файл проекта на Go;
